<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content="hexo, autumn, phosphorus15, cs">
    <title>
        Phosphorus&#39; Blog
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://github.githubassets.com/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@1.0.0/dist/hexo-infinite-scroll.min.css">
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@1.0.0/dist/hexo-infinite-scroll.min.js"></script>
    <script>
        infiniteScroll()

        // for mobile menu
        $(function () {
            $('.social-button').click(function () {
                if ($('.social-links').hasClass('hide-links')) {
                    $('.social-links').removeClass('hide-links')
                } else {
                    $('.social-links').addClass('hide-links')
                }
            })
        })
    </script>
</head>

    <body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <div class="container">
            <header class="header">
    <h1 class="title">
        <a href="/" class="logo">
            Phosphorus&#39; Blog
        </a>
    </h1>
    <h2 class="desc">
        Learning, Discovering, Exploiting
    </h2>

    <nav class="links">
        <button class="social-button">
            menu
        </button>
        <ul class="social-links hide-links">
            
                <li>
                    <a href="https://github.com/Phosphorus15">
                        Github
                    </a>
                </li>
                
                <li>
                    <a href="https://blog.csdn.net/wxx1237/">
                        CSDN
                    </a>
                </li>
                
        </ul>
    </nav>
</header>
                <main class="main">
                    <article class="post">
    
    
    
    <h2 class="post-title">
        LLVM IR Builder 小结
    </h2>
    <ul class="post-date">
        <li>
            2019-05-29
        </li>
        <li>
            Phosphorus15
        </li>
    </ul>
    <div class="post-content">
        <p>​    在使用<code>LLVM</code>作为编程语言（尤其是静态语言）后端时，生成<code>IR</code>是一切优化、检查和进一步编译的基础。因此，熟练使用<code>IR Builder</code>尤为重要。</p>
<p>​    以下笔者将以几段代码为基础，简述<code>LLVM IR Builder</code>中的主要方法和相关类型。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>​    为了顺利编译和运行本文中的代码，你需要：</p>
<ul>
<li><p>已配置好的<code>llvm</code>环境</p>
</li>
<li><p>确保<code>llvm</code>的头文件位置已被正确包含</p>
</li>
<li><p>确认<code>llvm</code>的相关库已被正确链接</p>
<p>笔者使用<code>cmake 1.3.5</code>进行构建,<code>CMakeLists.txt</code>如下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(TestLLVM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">"/usr/include/llvm/"</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">"/usr/include/llvm-c/"</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="string">"/usr/lib/llvm-6.0/lib/libLLVM.so"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="创建-IR-Builder"><a href="#创建-IR-Builder" class="headerlink" title="创建 IR Builder"></a>创建 IR Builder</h3><p>​    在正确配置了<code>llvm</code>后，就可以创建和使用<code>IR Builder</code>了，以下是一段（很长的）模板代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/APFloat.h"</span> <span class="comment">// 所有相关头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/ADT/STLExtras.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/BasicBlock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Function.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Type.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/IR/Verifier.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Support/raw_os_ostream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> llvm::LLVMContext context;</span><br><span class="line"><span class="keyword">static</span> llvm::IRBuilder&lt;&gt; builder(context);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;llvm::Module&gt; global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    global = <span class="built_in">std</span>::make_unique&lt;llvm::Module&gt;(<span class="string">"&lt;test&gt;"</span>, context);</span><br><span class="line">    <span class="comment">// write whatever you want</span></span><br><span class="line">    global-&gt;print(llvm::outs(), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    头文件多得吓人？没关系，这就是我们需要的所有头文件了。当然，很多情况下，把这些头文件用一个单独的头文件包含确实会让代码显得更简洁。</p>
<p>​    在上述代码中，我们定义了三个全局变量，意义分别如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> llvm::LLVMContext context;</span><br><span class="line"><span class="comment">// 当前LLVM的上下文</span></span><br><span class="line"><span class="keyword">static</span> llvm::IRBuilder&lt;&gt; builder(context);</span><br><span class="line"><span class="comment">// IR Builder， 我们最想要的东西</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;llvm::Module&gt; global;</span><br><span class="line"><span class="comment">// 我们构造的 llvm 模块，如果你不知道什么是“模块”，建议先去了解一下 llvm 的架构</span></span><br></pre></td></tr></table></figure>
<p>​    这三件套是我们构建<code>llvm</code>模块的基础。在这里，“模块”只是一个预留的空指针，我们需要真正向<code>IR Builder</code>“声明”这个模块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global = <span class="built_in">std</span>::make_unique&lt;llvm::Module&gt;(<span class="string">"&lt;test&gt;"</span>, context);</span><br><span class="line"><span class="comment">// 创建一个模块，以`context`为上下文，名字为`&lt;test&gt;`</span></span><br></pre></td></tr></table></figure>
<p>​    如果你不熟悉<code>C++</code>的智能指针，上述代码可以看作（其实它们并不等价）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global = <span class="keyword">new</span> llvm::Module(<span class="string">"&lt;test&gt;"</span>, context);</span><br></pre></td></tr></table></figure>
<p>​    在“声明”了模块后，<code>&lt;test&gt;</code>模块便实际存在于上下文中了，我们可以用以下代码来显示这个模块的<code>IR Code</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global-&gt;print(llvm::outs(), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// llvm::outs() 指向 stdout （标准输出流）</span></span><br></pre></td></tr></table></figure>
<p>​    此时，编译运行，我们会获得以下输出</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;ModuleID = <span class="string">'&lt;test&gt;'</span></span><br></pre></td></tr></table></figure>
<p>​    模块是空的，所以我们只看到了<code>ModuleID</code>的定义:joy:。但至少，我们已经向生成正经的<code>IR</code>迈出一小步了，不是吗？</p>
<h3 id="创建全局变量（常量）"><a href="#创建全局变量（常量）" class="headerlink" title="创建全局变量（常量）"></a>创建全局变量（常量）</h3><p>模块</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> intType = llvm::Type::getInt32Ty(context); </span><br><span class="line"><span class="comment">// 获取int32类型</span></span><br><span class="line"><span class="keyword">auto</span> num = llvm::ConstantInt::get( <span class="comment">// 创建常量（值）</span></span><br><span class="line">    intType <span class="comment">// 类型</span></span><br><span class="line">    , llvm::APInt(<span class="number">32</span>, <span class="number">233</span>)); <span class="comment">// 常量的值， APInt(32, 233) 代表 32 位无符号的 `233`</span></span><br><span class="line"><span class="keyword">auto</span> test = <span class="keyword">new</span> llvm::GlobalVariable( <span class="comment">// 创建全局常量</span></span><br><span class="line">    *global.get() <span class="comment">// 当前 module</span></span><br><span class="line">    , intType <span class="comment">// 类型</span></span><br><span class="line">    , <span class="literal">true</span> <span class="comment">// 是否为常量 - 如果为false，则是创建变量</span></span><br><span class="line">    , llvm::GlobalVariable::ExternalLinkage <span class="comment">// 链接类型</span></span><br><span class="line">    , num <span class="comment">// 全局常量对应的值</span></span><br><span class="line">    , <span class="string">"test"</span>); <span class="comment">// 全局常量的名称</span></span><br></pre></td></tr></table></figure>
<p>​    添加代码后运行程序，会获得以下输出</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">'&lt;test&gt;'</span></span><br><span class="line"></span><br><span class="line">@test = constant i32 <span class="number">233</span></span><br></pre></td></tr></table></figure>
<p>​    可以看到，模块中增加了对<code>test</code>常量的定义，是类型为32位整型的<code>233</code>值。</p>
<p>​    同样的，也可以添加字符串等特殊类型的全局变量/常量，只是步骤更为复杂。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Hello, LLVM !"</span>;</span><br><span class="line"><span class="comment">// 要定义为全局变量的字符串</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;llvm::Constant *&gt; bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> byteType = llvm::Type::getInt8Ty(context);</span><br><span class="line"><span class="comment">// 获取 int8 类型</span></span><br><span class="line"><span class="keyword">auto</span> byteArrayType = llvm::ArrayType::get(byteType, str.size());</span><br><span class="line"><span class="comment">// 获取字符串类型（字节数组）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">    bytes.push_back( <span class="comment">// 将每个字符依次定义为int8的常值</span></span><br><span class="line">    	llvm::ConstantInt::get(</span><br><span class="line">            byteType</span><br><span class="line">            , llvm::APInt(<span class="number">8</span>, c)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> byteArray = llvm::ConstantArray::get( <span class="comment">// 创建int8数组</span></span><br><span class="line">    byteArrayType</span><br><span class="line">    , bytes);</span><br><span class="line"><span class="keyword">auto</span> _str = <span class="keyword">new</span> llvm::GlobalVariable(*global.get(), byteArrayType <span class="comment">// 创建全局变量</span></span><br><span class="line">	, <span class="literal">false</span> <span class="comment">//  这里设置为false，代表变量而非常量</span></span><br><span class="line">    , llvm::GlobalVariable::ExternalLinkage</span><br><span class="line">    , byteArray, <span class="string">"str"</span>);</span><br></pre></td></tr></table></figure>
<p>​    添加上述代码后运行程序，获得以下输出：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">'&lt;test&gt;'</span></span><br><span class="line"></span><br><span class="line">@test = constant i32 <span class="number">233</span></span><br><span class="line">@str = global [<span class="number">13</span> x i8] c<span class="string">"Hello, LLVM !"</span></span><br></pre></td></tr></table></figure>
<p>​    通过<code>llc</code>对输出进行编译，可以获得以下汇编（amd64架构）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">phosphorus15@ubuntu:~/llvm-test$ ./llir1 | llc</span><br><span class="line">        .text</span><br><span class="line">        .file   &quot;&lt;stdin&gt;&quot;</span><br><span class="line">        .type   test,@object            # @test</span><br><span class="line">        .section        .rodata,&quot;a&quot;,@progbits</span><br><span class="line">        .globl  test</span><br><span class="line">        .align  4</span><br><span class="line">test:</span><br><span class="line">        .long   233                     # 0xe9</span><br><span class="line">        .size   test, 4</span><br><span class="line"></span><br><span class="line">        .type   str,@object             # @str</span><br><span class="line">        .data</span><br><span class="line">        .globl  str</span><br><span class="line">str:</span><br><span class="line">        .ascii  &quot;Hello, LLVM !&quot;</span><br><span class="line">        .size   str, 13</span><br><span class="line">        .section        &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><p>​    与传统C++类似，<code>llvm</code>的代码段也都是包含在函数内的，声明函数是构造指令与代码逻辑的基础。同时，函数声明也用于显式地链接来自外部库的函数。（如<code>libc</code>中的函数）</p>
<p>​    以C系最熟悉的<code>main</code>函数为例，我们用以下代码进行声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> intType = llvm::Type::getInt32Ty(context);</span><br><span class="line"><span class="keyword">auto</span> bytePtrType = llvm::Type::getInt8PtrTy(context);</span><br><span class="line"><span class="comment">// 获取int8指针类型</span></span><br><span class="line"><span class="keyword">auto</span> byteArrPtrType = byteType-&gt;getPointerTo();</span><br><span class="line"><span class="comment">// 获取int8双重指针类型</span></span><br><span class="line"></span><br><span class="line">global-&gt;getOrInsertFunction(<span class="string">"main"</span> <span class="comment">// 声明或获取已声明的函数</span></span><br><span class="line">	, intType <span class="comment">// 返回值类型</span></span><br><span class="line">	, intType, byteArrPtrType); <span class="comment">// 参数类型 （变长参数表）</span></span><br></pre></td></tr></table></figure>
<p>​    添加并运行以上代码，获得输出</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">'&lt;test&gt;'</span></span><br><span class="line">source_filename = <span class="string">"&lt;test&gt;"</span></span><br><span class="line"></span><br><span class="line">declare i32 @main(i32, i8**)</span><br></pre></td></tr></table></figure>
<p>​    我们也可以选择以构造函数对象的方式来给模块声明函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;llvm::Type *&gt; printfArgs;</span><br><span class="line"><span class="comment">// 参数类型列表</span></span><br><span class="line">printfArgs.push_back(byteArrType);</span><br><span class="line"><span class="keyword">auto</span> printfType = llvm::FunctionType::get( <span class="comment">// 创建函数类型</span></span><br><span class="line">    intType <span class="comment">// 返回值</span></span><br><span class="line">    , printfArgs <span class="comment">// 参数</span></span><br><span class="line">    , <span class="literal">true</span>); <span class="comment">// 是否为不定长参数</span></span><br><span class="line">llvm::Function::Create(printfType <span class="comment">// 通过函数类型来声明函数</span></span><br><span class="line">	, llvm::Function::ExternalWeakLinkage <span class="comment">// 弱extern链接</span></span><br><span class="line">	, <span class="string">"printf"</span> <span class="comment">// 函数名</span></span><br><span class="line">    , global.get()); <span class="comment">// 声明函数的模块</span></span><br></pre></td></tr></table></figure>
<p>​    添加并运行以上代码，获得向应输出</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">'&lt;test&gt;'</span></span><br><span class="line">source_filename = <span class="string">"&lt;test&gt;"</span></span><br><span class="line"></span><br><span class="line">declare i32 @main(i32, i8**)</span><br><span class="line"></span><br><span class="line">declare extern_weak i32 @printf(i8*, ...)</span><br></pre></td></tr></table></figure>
<p>​    模块的函数声明只能有两种链接类型，<code>extern</code>（默认类型）和<code>extern_weak</code>，在<code>printf</code>函数的声明中，我们显式地指定了<code>ExternalWeakLinkage</code>，因此在输出的<code>IR Code</code>中有<code>extern_weak</code>修饰符。</p>
<h3 id="基础指令集：-运算，返回与调用"><a href="#基础指令集：-运算，返回与调用" class="headerlink" title="基础指令集： 运算，返回与调用"></a>基础指令集： 运算，返回与调用</h3><h4 id="LLVM-的-“值”"><a href="#LLVM-的-“值”" class="headerlink" title="LLVM 的 “值”"></a>LLVM 的 “值”</h4><p>​    在进入本节前，不妨先看一看<code>LLVM</code>系统中各种“值”的表示方式。</p>
<p>​    下图是一个取自官方文档的<code>Value</code>类继承结构图。从图中可以看出，不论是<code>常量值</code>，<code>立即数值（数值常量）</code>，还是全局变量甚至指令，都继承了<code>llvm::User</code>，而<code>llvm::User</code>是<code>llvm::Value</code>的子类。确实，在构建<code>IR</code>的过程中，我们就是以<code>llvm::Value</code>为基指明我们<code>IR</code>所操作的对象的。</p>
<p>​    这种表示方式带来的好处是显而易见的——在很多熟悉的汇编指令集中，我们都需要给功能相同、但是参数类型不同（如寄存器/立即数/内存）的情形使用特定的指令。而<code>llvm</code>系统中值的继承方式，让我们在构建逻辑正确的前提下，避免区分不同值的“性质”而带来的烦恼。</p>
<p>​    <img src="http://llvm.org/doxygen/classllvm_1_1Value__inherit__graph.png" alt="Value Type Diagram"></p>
<h4 id="在函数中构建指令"><a href="#在函数中构建指令" class="headerlink" title="在函数中构建指令"></a>在函数中构建指令</h4><p>​    一段正确的的<code>IR</code>构建示范如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> functionBar = llvm::cast&lt;llvm::Function&gt;(</span><br><span class="line">    global-&gt;getOrInsertFunction(<span class="string">"bar"</span>, intType, intType, intType, intType));</span><br><span class="line"><span class="comment">// 声明函数 int32 bar(int32, int32, int32)</span></span><br><span class="line"><span class="comment">// llvm::cast 将返回的指针转为 llvm::Function 指针</span></span><br><span class="line"><span class="keyword">auto</span> blockEntry = llvm::BasicBlock::Create(context, <span class="string">"entry"</span>, functionBar);</span><br><span class="line"><span class="comment">// 创建一个位于bar函数中的代码块 "entry"</span></span><br><span class="line"><span class="keyword">auto</span> functionArgs = functionBar-&gt;args();</span><br><span class="line"><span class="comment">// 获取函数的参数列表 （可以理解为“实参列表”）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;llvm::Value *&gt; argsVector;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; arg : functionArgs) &#123;</span><br><span class="line">    arg.setName(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="number">1</span>, <span class="string">'a'</span> + (index ++)));</span><br><span class="line">    argsVector.push_back(&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	上面的循环将bar函数的三个参数按顺序存到了本地的std::vector里</span></span><br><span class="line"><span class="comment">	并分别命名为 a,b,c （命名只是为了标识，没有实际意义）</span></span><br><span class="line"><span class="comment">	此时函数声明为 int32 bar(int32 a, int32 b, int32 c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">builder.SetInsertPoint(blockEntry);</span><br><span class="line"><span class="comment">// 设置IR Builder的插入点为"entry"块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> addtmp = builder.CreateAdd(argsVector[<span class="number">0</span>], argsVector[<span class="number">1</span>], <span class="string">"addtmp"</span>);</span><br><span class="line"><span class="comment">// 插入 add 指令，以a和b为参数，将运算结果存到 addtmp 中</span></span><br><span class="line"><span class="keyword">auto</span> ret = builder.CreateMul(addtmp, argsVector[<span class="number">2</span>], <span class="string">"retValue"</span>);</span><br><span class="line"><span class="comment">// 插入 mul 指令，以addtmp和c为参数，将运算结果存到 retValue 中</span></span><br><span class="line">builder.CreateRet(ret);</span><br><span class="line"><span class="comment">// 插入 ret 指令，把retValue作为返回值</span></span><br><span class="line"></span><br><span class="line">llvm::verifyFunction(*functionBar, &amp;llvm::errs());</span><br><span class="line"><span class="comment">// 验证函数构建是否存在错误</span></span><br></pre></td></tr></table></figure>
<p>​    以上代码会获得输出：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">'&lt;test&gt;'</span></span><br><span class="line">source_filename = <span class="string">"&lt;test&gt;"</span></span><br><span class="line"></span><br><span class="line">define i32 @bar(i32 %a, i32 %b, i32 %c) &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  %addtmp = add i32 %a, %b</span><br><span class="line">  %retValue = mul i32 %addtmp, %c</span><br><span class="line">  ret i32 %retValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    把这段<code>IR Code</code>交给<code>llc</code>生成汇编，可以看到生成的关键代码（x86架构），验证了生成的<code>IR Code</code>符合我们的预期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bar:                                    # @bar</span><br><span class="line">        .cfi_startproc</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">        movl    4(%esp), %eax</span><br><span class="line">        addl    8(%esp), %eax</span><br><span class="line">        imull   12(%esp), %eax</span><br><span class="line">        retl</span><br><span class="line">.Lfunc_end0:</span><br><span class="line">        .size   bar, .Lfunc_end0-bar</span><br><span class="line">        .cfi_endproc</span><br><span class="line">                                        # -- End function</span><br></pre></td></tr></table></figure>
<p>​    在每次函数构建完成后，利用<code>llvm::verifyFunction</code>验证构建的<code>IR Code</code>是否正确十分重要，<code>llvm</code>并不强制你进行验证，但及时进行验证总是一种好习惯。</p>
<p>​    在上述代码中，如果去掉<code>builder.CreateRet(ret);</code>一句（即不创建返回语句），在运行程序时，会看到一句来自<code>llvm::verifyFunction</code>的信息，警告你函数并未正确终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Basic Block in function &apos;bar&apos; does not have terminator!</span><br><span class="line">label %entry</span><br></pre></td></tr></table></figure>
<p>​    这也是<code>llvm</code>系统便利性的又一体现——在<code>IR</code>表示下，系统有着完整且可扩展的验证/优化/编译套件，而且大部分都是可选的模块化组件，支持十分完善。</p>
<p>​    <del>今天成功把<code>llvm</code>开发环境从虚拟机迁移到<code>wsl</code>了，很开心www</del></p>
<h4 id="构建函数调用"><a href="#构建函数调用" class="headerlink" title="构建函数调用"></a>构建函数调用</h4>
    </div>
</article>
                </main>
                <aside class="aside">
                    <section class="aside-section">
                        
    <h1>Categories</h1>

    

                    </section>
                    <section class="aside-section">
                        
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li></ul>


                    </section>
                    <section class="aside-section tag">
                        
    <h1>Tags</h1>

    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/article/">article</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binary/">binary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compiler/">compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cuda/">cuda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/environment-setup/">environment setup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/heap/">heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/llvm/">llvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-language/">programming language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scientific-computing/">scientific computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/script/">script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tips/">tips</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/writeup/">writeup</a></li></ul>

                    </section>
                </aside>
        </div>
    </body>

</html>