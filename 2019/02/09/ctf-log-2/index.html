<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content="hexo, autumn, phosphorus15, cs">
    <title>
        Phosphorus&#39; Blog
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@1.0.0/dist/hexo-infinite-scroll.min.css">
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@1.0.0/dist/hexo-infinite-scroll.min.js"></script>
    <script>
        infiniteScroll()

        // for mobile menu
        $(function () {
            $('.social-button').click(function () {
                if ($('.social-links').hasClass('hide-links')) {
                    $('.social-links').removeClass('hide-links')
                } else {
                    $('.social-links').addClass('hide-links')
                }
            })
        })
    </script>
</head>

    <body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <div class="container">
            <header class="header">
    <h1 class="title">
        <a href="/" class="logo">
            Phosphorus&#39; Blog
        </a>
    </h1>
    <h2 class="desc">
        Learning, Discovering, Exploiting
    </h2>

    <nav class="links">
        <button class="social-button">
            menu
        </button>
        <ul class="social-links hide-links">
            
                <li>
                    <a href="https://github.com/Phosphorus15">
                        Github
                    </a>
                </li>
                
                <li>
                    <a href="https://blog.csdn.net/wxx1237/">
                        CSDN
                    </a>
                </li>
                
        </ul>
    </nav>
</header>
                <main class="main">
                    <article class="post">
    
    
    
    <h2 class="post-title">
        15号的CTF日记 (二)
    </h2>
    <ul class="post-date">
        <li>
            2019-02-09
        </li>
        <li>
            Phosphorus15
        </li>
    </ul>
    <div class="post-content">
        <p>今天是CTF的第二天，因为白天有一些<strong>小事情</strong>要做，所以只有晚上才能学习啦~</p>
<p>​    晚上蓝学长有比赛要打。。于是让窝自己看一看栈溢出的相关内容，虽然今天的进度只到了初步的ROP，但是也有不少收获~</p>
<p>​    </p>
<h4 id="StackOverflow-栈溢出"><a href="#StackOverflow-栈溢出" class="headerlink" title="StackOverflow - 栈溢出"></a><em>StackOverflow</em> - 栈溢出</h4><h5 id="栈帧，参数与返回值"><a href="#栈帧，参数与返回值" class="headerlink" title="栈帧，参数与返回值"></a>栈帧，参数与返回值</h5><p>​    我对于堆栈的了解，多半止步于16位汇编，虽然知道其在函数调用中所起到的保存参数和地址的作用，但却对32位、64位下的栈已经寄存器的标准协作情况缺乏了解。以下，我对一些曾经不是很清晰或者从未知晓的知识点进行记录</p>
<ul>
<li><p>32/64位的栈帧结构</p>
<p>采用<code>EBP</code>与<code>ESP</code>寄存器分别表示<strong>帧</strong>基和栈顶，栈顶在低位，帧基在高位。栈基处可用于保存返回地址以及部分寄存器信息。（其实返回地址本质上也是寄存器信息）</p>
<p>按照经验，结构体成员变量的入栈顺序与声明顺序相反。</p>
</li>
<li><p>函数调用时的具体堆栈操作</p>
<ol>
<li>主调函数按照函数调用约定，将参数压栈 （<code>x86_64</code>通常将头六个参数保存在寄存器中）</li>
<li>主调函数转交控制权给被调函数，<code>EIP</code>压栈（<code>call</code>指令）</li>
<li>被调函数可能会设置帧基指针，并保存原寄存器值</li>
<li>被调函数分配自身的栈空间（向低地址方向存放临时变量）</li>
<li>被调函数执行任务（返回值通常在指定寄存器中，如<code>EAX</code>）</li>
<li>释放分配的栈空间</li>
<li>回复寄存器指和帧基指针寄存器</li>
<li>被调函数叫唤控制权给被调函数</li>
<li>主调函数清除先前的参数（可能）</li>
</ol>
</li>
<li><p>函数序(prologue)与函数跋(epilogue)</p>
<p>上述步骤3,4称为<code>函数序</code>，6,7,8作为相反操作，称为<code>函数跋</code></p>
<p>C调用约定下的函数序与函数跋（值得注意的是，这两者一般都是由被调函数完成的）：</p>
<p><strong>函数序</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push %ebp # 将主调函数帧基指针压栈</span><br><span class="line">mov %esp, %ebp # 将栈顶指针赋给帧基指针</span><br><span class="line">sub &lt;n&gt;, %esp # 将栈顶指针减去指定字节数，为被调函数局部变量开辟空间 （n为立即数且一般为16的倍数）</span><br><span class="line">push &lt;r&gt; # 可选，如有必要，被调函数负责保存某些寄存器的值</span><br></pre></td></tr></table></figure>
<p><strong>函数跋</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop &lt;r&gt; # 可选，如有必要，被调函数负责恢复某些寄存器的值</span><br><span class="line">mov %ebp, %esp # 恢复栈顶指针，释放栈空间</span><br><span class="line">pop %ebp # 主调函数栈基指针出栈</span><br><span class="line"># 以上两条也可以用 leave 代替</span><br><span class="line">ret # 从栈顶弹出主调函数压在栈中的返回地址到 EIP 中，跳回主调函数继续执行，由主调函数恢复调用前的栈</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数压栈方式</strong>视编译器而异，如直接<code>push</code>或者使用<code>subl</code>与<code>movl</code>命令直接将内容存入栈中</p>
</li>
<li><p>函数<strong>调用约定</strong>：</p>
<p>通常包含三个方面的内容： 函数参数的传递顺序和方式、栈的维护方式与名字修饰策略</p>
<p>常见的调用约定如下表（取自<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html" target="_blank" rel="noopener">cnblogs</a>）：</p>
<p>| <strong>调用方式</strong>       | <strong>stdcall(Win32)</strong> | <strong>cdecl</strong> | <strong>fastcall</strong>                   | <strong>thiscall(C++)</strong>       | <strong>naked call</strong> |<br>| —————— | —————— | ——— | —————————— | ———————– | ————– |<br>| <strong>参数压栈顺序</strong>   | 从右至左           | 从右至左  | 从右至左，Arg1在ecx，Arg2在edx | 从右至左，this指针在ecx | 自定义         |<br>| <strong>参数位置</strong>       | 栈                 | 栈        | 栈 + 寄存器                    | 栈，寄存器ecx           | 自定义         |<br>| <strong>负责清栈的函数</strong> | 被调函数           | 主调函数  | 被调函数                       | 被调函数                | 自定义         |<br>| <strong>支持可变参数</strong>   | 否                 | 是        | 否                             | 否                      | 自定义         |<br>| <strong>函数名字格式</strong>   | _name@number       | _name     | @name@number                   |                         | 自定义         |<br>| <strong>参数表开始标识</strong> | “@@YG”             | “@@YA”    | “@@YI”                         |                         | 自定义         |</p>
<p><em>C++因支持重载、命名空间等，名字修饰策略更为复杂</em>（一般为’?’开头）</p>
</li>
<li><p>特殊参数传递</p>
<p><em>浮点型</em>的传参方式与整型类似，主要差异在于大小。</p>
<p><em>结构体和联合体</em>主要区别也在大小，如在x86处理器上，这两者会被填充补齐到4字节的倍数。</p>
<p>在一些<code>RISC</code>处理器上，大部分传参通过特殊的寄存器实现（如<code>PowerPC</code>上的<code>R3~R10</code>用于传递整型和指针，<code>F1~F8</code>用于传递浮点）</p>
</li>
<li><p><code>x86</code>下函数返回值的传递方法</p>
<ol>
<li><p>不超过四字节的，保存在<code>EAX</code>寄存器中</p>
</li>
<li><p>小于八字节的，使用<code>EAX</code>+<code>EDX</code>联合存储，其中<code>EDX</code>保存高位</p>
</li>
<li><p>浮点类型由协处理器（<code>FPU</code>?）浮点数寄存器栈返回</p>
</li>
<li><p>结构体与联合体由主调函数向被调函数传递一个额外的<strong>隐藏参数</strong>，指向保存返回值的地址（将实参逆序入栈后，再将接收返回值的地址入栈），被调函数最后会将此地址保存在<code>EAX</code>中</p>
<p><em>注：某些编译器下，小于八字节的结构体会以EAX+EDX的形式返回</em></p>
</li>
</ol>
</li>
</ul>
<p>以下是一张64位下的整型寄存器图</p>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/figure/register.png" alt="img"></p>
<h5 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h5><p><strong>定义</strong>：栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。</p>
<p><strong>基本前提</strong>：</p>
<ul>
<li>程序必须向栈上写入数据</li>
<li>写入的数据大小没有被良好地控制</li>
</ul>
<p><strong>操作</strong>：通过覆盖地址的方法来直接或者间接地控制程序执行流程。（如修改返回地址从而实现函数调用）</p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic/#_4" target="_blank" rel="noopener">一个例子</a></p>
<h5 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP (Return Oriented Programming)"></a>ROP (Return Oriented Programming)</h5><p><strong>主要思想</strong>：在缓冲区溢出的基础上，利用程序中已有的<em>小片段</em>(Gadgets)来改变某些寄存器或变量的值，从而控制程序的执行流程</p>
<p><strong>Gadgets</strong>: 以<code>ret</code>结尾的指令序列</p>
<p><strong>前提条件</strong>:</p>
<ul>
<li>程序存在溢出，并且可以控制返回地址。</li>
<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>
</ul>

    </div>
</article>
                </main>
                <aside class="aside">
                    <section class="aside-section">
                        
    <h1>Categories</h1>

    

                    </section>
                    <section class="aside-section">
                        
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li></ul>


                    </section>
                    <section class="aside-section tag">
                        
    <h1>Tags</h1>

    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/article/">article</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cybersecurity/">cybersecurity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a></li></ul>

                    </section>
                </aside>
        </div>
    </body>

</html>